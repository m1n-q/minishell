# minishell


## 규칙

`$a$d` 같이 환경변수 끼리의 join 뿐만이 아니라

`123$a` 같은 그냥 arg와의 join도 마찬가지임.
그럼 env_has_space(argv[0]) 가 아니라, 
문자열 중간에서 확장된 경우도 split_and_join_till 로 가야할 듯.



### 따옴표 없으면

- 공백을 기준으로 <u>따옴표 내부 split</u>
- `$a  $b` 같이 이어지지 않은 arg이면 그냥 자기 자리에 <u>**split 한 배열채**</u>로 넣으면 댐



1. 'ls -l': `$a$b` 처럼 이어지면 인접한 arg에, "**arg 하나만**" 갖다붙임  
             (인접부분 합쳐진 문자열 1개 생김)
2. 앞, 혹은 뒤에 <u>공백이 있는</u> ' ls -l': `$a$b` 처럼 이어져도 **인접한 arg와 별개의 arg로**

### 따옴표 있으면

- 일단 <u>따옴표 내부</u>는 스플릿을 안함 
- `$a  $b` 같이 이어지지 않은 arg이면 그냥 그자리에 **<u>확장된 문자열 자체</u>**로 넣으면 댐
- 앞 뒤에 공백이 있든 없든 :  `"$a"$b` 나 `$a"$b"` 처럼 이어지면,  
                      <u>**확장된 문자열 통째**</u>로 **"인접한 arg 하나"**에 갖다붙임  
                      (인접부분 합쳐진 문자열 1개 생김)




## 진행상태
```C
  기존에는

  a='ls -l';
  b='   wc  -l  ';

  과 같은 경우 $a"$b" 에서 b 앞부분 공백이 다 사라져서 나와서
  trim_space_in_env(); 함수를 지우고 처리했는데,
  혹시 이 부분에서 문제가 될만한 부분이 있을지 모르겠습니다!

  어차피 expand 되면 split으로 들어가니 괜찮을 것 같긴 한데, 예외가 있을지 잘 모르겠습니다/

```
---

```C
  일단 위 규칙에 따라 어느정도 구현 한 것 같은데,
  $a"$d" 같은 경우, 
  cpy_wo_q(); 가 실행되고 a의내용"d의내용" 식으로 quoting 되어 나오나,
  
  "$a"$d 같은 경우, 
  cpy_with_q(); 가 실행되고 a의내용d의내용 식으로 나와서 공백을 무시하고 하나로 취급할 (스플릿에서 배제할)부분을 알 수 없습니다.

  상의드릴 부분이라 했던 것은 cpy_with_q() 에서도 quotes 내 expand를 한 경우,
  나중에 제가 작성한 부분에서 quotes 는 제거되기 때문에 감싸서 나오면 어떨지, 다른 문제가 생길지 여쭈려고 했습니다!;

  
  테스트가 필요한 함수:
    split2(); : quotes로 감싸진 부분을 배제한 공백 스플릿 함수 
    count_n_skip(); : 주석 따로 적어두었습니다. 근데 argc 꼭 안맞추면 괜찮긴 합니다 ㅎㅎ..

  코드 상태랑 주석이 좀 많이 지저분해서 양해부탁드리고..

  a='ls -l';
  b='ls -l  ';
  c='  wc -l';
  d='  ls -l  ';
  e=abc;

  위 변수로 cat $a"$d""$e" 등 여러가지 조합으로 해보았을때 괜찮았던 것 같은데 더 돌려봐야 알 것 같아요
  근데 아마 위의 문제만 해결되면 될 것 같긴 합니다.


```
